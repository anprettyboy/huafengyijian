(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{392:function(e,a,n){"use strict";n.r(a);var s=n(54),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"聊聊常见的asset-chunk-optimization卡顿"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#聊聊常见的asset-chunk-optimization卡顿"}},[e._v("#")]),e._v(" 聊聊常见的Asset Chunk Optimization卡顿")]),e._v(" "),n("p",[n("b",[e._v("项")]),e._v("目中使用Webpack的项目，在每次编辑保存时候，总会看到热更新卡顿异常的Asset chunk optimization 9*%...,尤其是当项目大了以后，修改一个简单的css，webpack热更新都很慢。通过观察可以发现大部分的时间都耗在百分之九十(几) Asset Chunk Optimization 这一步上. 这时候对于前端工程师而言，是无比浪费时间(煎熬)的，笔者个人而言，每天编码工作，大量的Control Save(保存)操作据不完全统计至少有几百上千次.目前构建工具而言，前端业内毫无疑问Webpack 占据着绝对统治地位,尤其在现在React Vue等主流组件化框架所建立的工程而言，每天的日常工作需要更改并保存大量的文件，每一次的保存势必要触发热更新，光是一个保存按钮就已经涉及到了Webpack优化的问题了\n这个问题也可以简单概括为"),n("b",[e._v("'webpack单页面，项目较大时，编译热加载缓慢'")]),e._v("....进而导致降低开发效率(毫无意义的等待)")]),e._v(" "),n("p",[e._v("我们大概分析下热更新卡顿的原因以及解决思路:")]),e._v(" "),n("p",[e._v("讲到热更新之前，有必要了解下热更新是啥？")]),e._v(" "),n("p",[e._v("热更新,英文全名Hot Module Reloading，缩写为HMR。引用官方文档，热更新是：使得应用在运行状态下，不重载刷新就能更新、增加、移除模块的机制.")]),e._v(" "),n("ol",[n("li",[n("b",[e._v("若")]),e._v("是多页应用,问题可能是出在html-webpack-plugin插件上，可以引入另一个插件html-webpack-plugin-for-multihtml测试下速度")])]),e._v(" "),n("ul",[n("li",[e._v("1.1 安装html-webpack-plugin-for-multihtml")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" npm i html-webpack-plugin-for-multihtml--save-dev\n")])])]),n("ul",[n("li",[e._v("1.2 更改配置")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("newHtmlWebpackPlugin({ \n\n title:'My App',\n\nfilename:'assets/admin.html',\n\nmultihtmlCache:true// 解决多页打包的关键\n\n}）\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("b",[e._v("减少不必要")]),e._v("的文件监听,加快webpack编译")])]),e._v(" "),n("ul",[n("li",[e._v("2.1 利用babel-loader缓存参数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("module.exports = {\n   module: {\n       noParse: /node_modules\\/(jquey|moment|chart\\.js)/,\n       rules: [\n           {\n               test: /\\.js$/,\n               loader: 'babel-loader?cacheDirectory',\n               include: [resolve('src'), resolve('test')],\n               exclude:/node_modules/\n           },\n       ]\n   }\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("- 2.2 忽略掉一些大的node_modules里面的模块\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("module.exports = {\n    module: {\n        //这里列出一些模块，根据自己项目去除一些编译的文件\n        noParse: /node_modules\\/(jquey|moment|chart\\.js)/,\n    }\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("- 2.3 开发环境中,只编译自己开发的模块和目录\n")])])]),n("p",[e._v("开发环境中，每人负责的都是一部分模块或者组件，所以热更新可以只编译自己当前需要的页面，而没必要把所有的页面全部编译。例如，前端Jack创建一个 selfConfig.js设置需要保存的页面，然后在 webpack 配置中去配置只属于Jack自己需要的页面去编译热更新。")]),e._v(" "),n("p",[e._v("伪代码示例:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// selfConfig.js\nmodule.exports = [\n    'imScence',\n    'mLogin'\n];\n\n// webpack.base.conf.js \n// 部分关键代码\nconst selfConfig = require(\"./selfConfig\");\n\nfor (let moduleName of modules) {\n    if (!selfConfig.length) {\n        devEntries[moduleName] = path.join(resolve('src'), 'modules', moduleName, 'main.js');\n    } \n    else {\n        if (selfConfig.includes(moduleName)) {\n            devEntries[moduleName] = path.join(resolve('src'), 'modules', moduleName, 'main.js');\n        }\n    }\n    //Webpack Entry\n    buildEntries[moduleName] = path.join(resolve('src'), 'modules', moduleName, 'main.js');\n}\n")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);